<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mosaico Experimental - Densidad M√°xima</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      font-family: monospace;
    }
    #grid {
      display: grid;
      width: 100vw;
      height: 100vh;
      background: #000;
      gap: 0;
    }
    .cell {
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      background: #000;
    }
    canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <div id="grid"></div>
  <!--<div class="info" id="info"></div>-->

  <script type="module">
    class SnapshotCompressor {
      constructor(w = 80, h = 80) {
        this.targetWidth = w;
        this.targetHeight = h;
      }
      hexToBytes(hex) {
        const bytes = [];
        for (let i = 0; i < hex.length; i += 2) {
          bytes.push(parseInt(hex.substr(i, 2), 16));
        }
        return bytes;
      }
      decompress2bpp(bytes) {
        const pixels = new Array(this.targetWidth * this.targetHeight);
        let pixelIndex = 0;
        for (let i = 0; i < bytes.length; i++) {
          const byte = bytes[i];
          for (let n = 0; n < 4; n++) {
            if (pixelIndex < pixels.length) {
              const shift = 6 - n * 2;
              const colorIndex = (byte >> shift) & 0x03;
              pixels[pixelIndex++] = colorIndex;
            }
          }
        }
        return pixels;
      }
      ditheredToImageData(dithered) {
        const palette = [
          [0, 0, 0],
          [85, 85, 85],
          [170, 170, 170],
          [255, 255, 255],
        ];
        const imageData = new ImageData(this.targetWidth, this.targetHeight);
        const data = imageData.data;
        for (let i = 0; i < dithered.length; i++) {
          const c = palette[dithered[i]];
          const di = i * 4;
          data[di] = c[0];
          data[di + 1] = c[1];
          data[di + 2] = c[2];
          data[di + 3] = 255;
        }
        return imageData;
      }
    }

    const compressor = new SnapshotCompressor();
    const grid = document.getElementById('grid');
    // const info = document.getElementById('info');

    async function loadSnapshots() {
      try {
        const res = await fetch('/api/nfc-events?limit=1200');
        if (!res.ok) throw new Error('Error fetching snapshots');
        
        let snapshots = await res.json();
        console.log('Snapshots cargados:', snapshots.length);

        // Ordenar por timestamp (m√°s recientes primero)
        snapshots.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // üëá C√ÅLCULO DE DENSIDAD M√ÅXIMA
        const availableWidth = window.innerWidth;
        const availableHeight = window.innerHeight;
        const totalArea = availableWidth * availableHeight;
        
        // Tama√±o te√≥rico para mostrar TODOS
        const theoreticalSize = Math.sqrt(totalArea / snapshots.length);
        
        // Dimensiones del grid
        let cols = Math.floor(availableWidth / theoreticalSize);
        let rows = Math.floor(availableHeight / theoreticalSize);
        let totalCells = cols * rows;

        // üëá OPTIMIZACI√ìN: ELIMINAR SNAPS VIEJOS
        if (snapshots.length > totalCells) {
          const snapshotsToRemove = snapshots.length - totalCells;
          snapshots = snapshots.slice(0, totalCells);
          console.log(`üóëÔ∏è Eliminados ${snapshotsToRemove} snaps m√°s viejos`);
        } else if (snapshots.length < totalCells) {
          const optimalRows = Math.ceil(snapshots.length / cols);
          if (optimalRows <= Math.floor(availableHeight / theoreticalSize)) {
            rows = optimalRows;
            totalCells = cols * rows;
          }
        }

        const finalCellSize = Math.min(availableWidth / cols, availableHeight / rows);
        
        // Actualizar info
        // info.textContent = `${cols}√ó${rows} | ${snapshots.length} snaps | ${finalCellSize.toFixed(1)}px`;

        // üëá APLICAR AL GRID
        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
        grid.innerHTML = '';

        // Renderizar snaps optimizados
        snapshots.forEach((snap, index) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = compressor.targetWidth;
          canvas.height = compressor.targetHeight;
          ctx.imageSmoothingEnabled = false;

          try {
            const bytes = compressor.hexToBytes(snap.snapshot_data);
            const dithered = compressor.decompress2bpp(bytes);
            const imgData = compressor.ditheredToImageData(dithered);

            // Canvas temporal para rotar
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = compressor.targetWidth;
            tempCanvas.height = compressor.targetHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imgData, 0, 0);

            // Rotar 90¬∞ horario
            ctx.save();
            ctx.translate(canvas.width, 0);
            ctx.rotate(Math.PI / 2);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
            
            cell.appendChild(canvas);
          } catch (error) {
            console.error('Error procesando snapshot', index, error);
            cell.style.background = 'rgba(255, 50, 50, 0.2)';
          }
          
          grid.appendChild(cell);
        });

        // Rellenar celdas vac√≠as si las hay
        const emptyCells = totalCells - snapshots.length;
        if (emptyCells > 0) {
          for (let i = 0; i < emptyCells; i++) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'cell';
            emptyCell.style.background = '#000';
            grid.appendChild(emptyCell);
          }
        }

        console.log('‚úÖ Mosaico optimizado cargado');
        
      } catch (error) {
        console.error('Error cargando mosaico:', error);
        //info.textContent = 'Error cargando mosaico';
        // info.style.background = 'rgba(255, 50, 50, 0.7)';
      }
    }

    // Manejar redimensionamiento
    let resizeTimeout;
    function handleResize() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        console.log('üîÑ Redimensionando mosaico...');
        loadSnapshots();
      }, 250);
    }

    // Inicializar
    loadSnapshots();
    window.addEventListener('resize', handleResize);

    // Info hover para m√°s detalles
    /*info.addEventListener('click', () => {
      info.style.display = info.style.display === 'none' ? 'block' : 'none';
    });
    */
  </script>
</body>
</html>